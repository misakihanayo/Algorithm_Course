# 算法基础 10.13

#### 复杂度分析

时间、空间、通信

算法、问题

Worst, average, best, smooth

Worst case:
$$
max_{i \in U} T_A(I)
$$
Best case:
$$
min_{i \in U} T_A(I)
$$
Average case:
$$
\Sigma_IP(I)T_A(I)
$$
Tail-Analysis:
$$
PR(T_A(I) \le f(n)) \ge 1-\epsilon
$$
Meaning of Smooth:
$$
I \to T_A(I) \quad may\ be\ slow. \\
I' \to T_A(I') \quad may\ be\ quicker. \\
and\ the\ solution\ may\ similar.
$$
问题复杂性分析
$$
Sorting\ A_c(comparison\ based) \\
a_1,a_2,a_3...a_n \\
Consider\ a\ step:compare(a_i,a_j) \\
A\ sequence\ have\ N!\ possible solutions.
$$
考虑一个决策树，每个节点表示比较的两个对象，这棵树就代表了排序问题的问题复杂度。

那么这棵树的叶子结点数量至少为N!。

由于决策树是严格二叉的，故这棵树的深度H，即比较次数H（时间复杂度）要满足
$$
2^H \ge N!
$$
因此我们就得出结论，
$$
H\ge lg_2(N!) = \Sigma_{i=1}^Nlog_2i=\Theta(NlogN)\\
H=\Omega(NlogN)
$$

#### Sort in linear time

##### Counting sort

###### Assumption

input elements ranges [0...K], K is small.

###### Time complexity: O(n+k)

#### Radix Sorting

...

#### Bucket Sorting



